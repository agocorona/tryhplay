<span class="c13">Haskell</span><span class="c14"> </span><span class="c13">tutorial</span><span class="c14">: how to create a small accounting application in your browser</span> {.c0 .c9}
==================================================================================================================================================================================

<span class="c2"></span>

<span class="c2">Haskell is magic and it is not as difficult to program
as you think and you can be productive very early if you use a high
level library for your domain problem.  leaving apart the academic
stuff, there are two programming levels in industrial Haskell: The one
of programmers that  creates Embedded Domain Specific Languages (EDSLs)
and the one where the programer simply use the EDSLs without much
concern about what is below. Or it should be. A mature and efficient
development ecosystem need both levels.</span>

<span class="c2"></span>

<span class="c2">This tutorial assumes that you have no knowledge of
Haskell, but you are interested and you are following a basic course
like </span><span class="c11 c3">[lean a
Haskell](http://www.google.com/url?q=http%3A%2F%2Flearnyouahaskell.com%2F&sa=D&sntz=1&usg=AFQjCNGHuZ_rZAyLavxCWgjt7uhLDlAkNA)</span><span
class="c2">. and you need to develop Browser applications from the first
day.   We will use the Haste compiler plus some libraries that bring a
high level DSL for the creation of client side web applications. We will
illustrate how to do it by creating a personal finance
application.</span>

<span class="c2"></span>

<span class="c2">The complete code and application running is at:</span>

<span class="c2"></span>

<span
class="c11 c3">[http://tryplayg.herokuapp.com/try/mybudget.hs/edit](http://www.google.com/url?q=http%3A%2F%2Ftryplayg.herokuapp.com%2Ftry%2Fmybudget.hs%2Fedit&sa=D&sntz=1&usg=AFQjCNEJd522qIcAKxQbhntLcoWUWEkhnQ)</span>

<span class="c2"></span>

<span class="c2">There have been exciting developments in the browser
side in Haskell thanks to some Haskell-to-javaScript compilers like
 </span><span
class="c11 c3">[fay](https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Ffaylang&sa=D&sntz=1&usg=AFQjCNHQX2DsUugTymRm_7ON2Z4oaxwJpA)</span><span
class="c2">, </span><span
class="c11 c3">[ghcjs](https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Fghcjs%2Fghcjs&sa=D&sntz=1&usg=AFQjCNEv7DHkso9CLQ2X2pYUP6_ihkM9-w)</span><span
class="c2">and </span><span
class="c11 c3">[haste](http://www.google.com/url?q=http%3A%2F%2Fhaste-lang.org%2F&sa=D&sntz=1&usg=AFQjCNGkAXLlXQd_2L2Ohx8vZmH3me0ofg)</span><span
class="c2">. The </span><span
class="c11 c3">[elm](http://www.google.com/url?q=http%3A%2F%2Felm-lang.org%2F&sa=D&sntz=1&usg=AFQjCNEibHOCGZnktkHcf6-PL7z3EIrX8g)</span><span
class="c2">project is a functional language, developed in Haskell that
compiles to javaScript. </span>

<span class="c2"></span>

<span class="c2">So there is a lot of effort and interest in haskell for
the client side. Browser programming It is probably the easiest  and
more casual way to enter in the world of Haskell and for Haskell the
most promising way to enter in industry. A program running on the
browser can be distributed and executed to any place and any device,
without the need of anything else. A Haskell development environment
that run in the web is immediately accessible to anyone.</span>

<span class="c2"></span>

<span class="c2">There is a lot of programmers in the browser side
investing many hours of effort trying to overcome the main problems of
client-side development: the explosive complexity of callback
programming model, how to easily create dynamic layouts easily by taming
the HTML-DOM tree, and last but not least, the dynamic typing of the
javascript language that makes decent size projects very hard to develop
and maintain.</span>

<span class="c2"></span>

<span class="c2">For these issues, Haskell has a lot to contribute. For
the last , the Haskell type system is the best tool for debugging,
integration and factorization. Integration and factorization in haskell
is like plugging cables to appliances: you know that if the socket does
not plug, it is not in the right place or you need an adapter. Writing
haskell is like sculpting in stone. Once the program compiles, it works,
specially if the program is coded in a high level EDSL. </span>

<span class="c2"></span>

<span class="c2">For the callback hell, the user can program imperative
statements and haskell will generate callbacks under the hood. That is
what the </span><span
class="c11 c3">[hplayground](https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Fagocorona%2Fhplayground&sa=D&sntz=1&usg=AFQjCNFnwlZ6mhhDcsz4VLKHEeMzrbgk9g)</span><span
class="c2">library does. It also manages form inputs and events within
this imperative style, with reactive modifications of the HTML DOM using
a high level library that makes writing new DOM elements on the fly as
easy as writing  plain HTML code. This is the </span><span
class="c11 c3">[perch](https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Fagocorona%2Fhaste-perch&sa=D&sntz=1&usg=AFQjCNFFPR-TH8XT6mJXt34MW7syEoBdKg)</span><span
class="c2"> </span><span class="c2">library.</span>

<span class="c2"></span>

<span>Installation</span> {.c0 .c9}
-------------------------

<span class="c2">Haste works over the Glorous Haskell Compiler (ghc).
 so you have to install </span><span class="c2 c8">ghc</span><span
class="c2">, </span><span class="c2 c8">haste</span><span class="c2">,
the haskell-to-javascript compiler and the two libraries </span><span
class="c2 c8">perch </span><span class="c2">and </span><span
class="c2 c8">hplayground</span><span class="c2">. The instructions are
at the end of the README of the hplayground library </span><span
class="c11 c3">[here](https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Fagocorona%2Fhplayground%2Fblob%2Fmaster%2FREADME.md&sa=D&sntz=1&usg=AFQjCNHWVMmEPbKNs6KmFN4dROVp-mJs1A)</span>

<span class="c2"></span>

<span class="c2">But you don't have to do it to have a glimpse of how it
works. </span><span
class="c11 c3">[Here](http://www.google.com/url?q=http%3A%2F%2Ftryplayg.herokuapp.com&sa=D&sntz=1&usg=AFQjCNFDrqlNKI9d6E-eB1wO3JVxvHUUow)</span><span
class="c2"> </span><span class="c2">you have the development environment
online. It is for playing purposes however, and works like a wiki. there
is no user authentication at this moment.</span>

<span class="c2"></span>

<span class="c2">Almost whatever ghc compiles, Haste can translate it to
JavaScript + HTML. Once the program is translated it can run in a web
browser. You can distribute it via Web applications, mail etc. Since
this program is purely client-side.</span>

<span class="c2"></span>

<span>The program:</span> {.c0 .c9}
-------------------------

<span class="c2"></span>

<span class="c2">The example program, explained above, is a simple
personal accounting utility.</span>

<span class="c2"></span>

<span class="c2">First, we define the basic account register that we
will use:</span>

<span class="c2 c6"></span>

<span class="c1">data EntryType= Travel | Food | Entertain | Other |
Income | AllEntries  deriving (Read,Show,Eq, Typeable)</span>

<span class="c1"></span>

<span class="c1">data Entry= Entry{day, month, year :: Int,description
:: String, amount :: Double, etype :: EntryType} deriving
(Read,Show)</span>

<span class="c2 c6"></span>

<span class="c2 c6"></span>

<span class="c2">As you can see, the register has a date, a description,
a amount of money spent, and a type which may be </span><span
class="c2 c5">Travel</span><span class="c2">, </span><span
class="c2 c5">Food</span><span class="c2">, </span><span
class="c2 c5">Entertainment</span><span class="c2">, </span><span
class="c2 c5">Other </span><span class="c2">or </span><span
class="c2 c5">Income</span><span class="c2">.  </span><span
class="c2 c5">AllEntries </span><span class="c2">is a wildcard used by
the application logic. </span>

<span class="c2"></span>

<span class="c2">The name in the left side is the type of the data. On
the right side there are the constructors of the type. In the case of
</span><span class="c2 c5">EntryType</span><span class="c2">, there are
five constructors with no parameters. In the </span><span
class="c2 c5">Entry </span><span class="c2">data, there is one
constructors which has six parameters.</span>

<span class="c2"></span>

<span class="c2">The deriving clause automatically create instances for
</span><span class="c2 c5">Read</span><span class="c2">, </span><span
class="c2 c5">Show </span><span class="c2">and </span><span
class="c2 c5">Typeable </span><span class="c2">that are required.
</span><span class="c2 c5">Show </span><span class="c2">writes the
register to a String and Read read this String and produces a
register.</span>

<span class="c2"></span>

<span class="c2">To store thar register in the new HTML5 local Storage,
we need to convert it to JSON- The class ins defined in the </span><span
class="c2 c8">Haste.JSON</span><span class="c2"> library of the
</span><span class="c2 c8">haste </span><span class="c2">compiler. We
will use a straightforward conversion using </span><span
class="c2 c5">read </span><span class="c2">and </span><span
class="c2 c5">show </span><span class="c2">instances:</span>

<span class="c2"></span>

<span class="c2"></span>

<span class="c2"></span>

<span class="c1">instance Serialize Entry where</span>

<span class="c1">  toJSON= Str . toJSString . show</span>

<span class="c1">  parseJSON (Str jss)=  return . read  \$ fromJSStr
jss</span>

<span class="c2"></span>

<span class="c2">It is not the best way. Javascript can not read it
since we serialize and deserialize the string produced by Show, which is
haskell, not a JSON register properly. But hey, we are just starting to
learn. There is no need to define any  other class or instance. The
</span><span class="c2 c5">\*JSString</span><span class="c2"> calls
convert from javaScript Strings to Haskell String and viceversa.</span>

<span class="c2"></span>

<span class="c2">And now the options that will be implemented:</span>

<span class="c2"></span>

<span class="c1">data MainOps= Edit | Detail | Preview </span>

<span class="c2"></span>

<span class="c2">That is, we will add/delete entries, we will consult
them and we will plan the future expenses</span>

<span class="c2"></span>

<span class="c2">And here is the main procedure:</span>

<span class="c2"></span>

<span class="c1">main= do</span>

<span class="c1">  addHeader googleGraph</span>

<span class="c1"></span>

<span class="c1">  runBody \$ do</span>

<span class="c1">    wraw \$ h1  "Personal Budget"  \<\> hr</span>

<span class="c1">  </span>

<span class="c1">    r \<- wbutton Edit "Edit" \<|\></span>

<span class="c1">         wbutton Detail "View Entries" \<|\> </span>

<span class="c1">         wbutton Prev "Preview expenses" </span>

<span class="c1">        </span>

<span class="c1">    case r of</span>

<span class="c1">        Edit -\> edit</span>

<span class="c1">        Detail -\> viewEntries</span>

<span class="c1">        Preview -\> preview</span>

<span class="c1">    return ()</span>

<span class="c2 c17"></span>

<span class="c2">In the first line we instruct the application to load
in the header the </span><span class="c11 c3">[google graph
api](https://developers.google.com/chart)</span><span class="c2"> with
the Chart module. We will need it to show chart graphs. This will be an
example of interaction of Haskell and Javascript using Haste. We will
see later the details of </span><span class="c2 c5">googleGraph.</span>

<span class="c2"></span>

<span class="c2 c8">hplayground </span><span class="c2">uses a haskell
library called </span><span class="c2 c8">perch </span><span
class="c2">that assemble unevaluated haskell functions instead of text
or HTML-DOM calls. These functions are called by the rendering engine
only if necessary. </span>

<span class="c2 c5"></span>

<span class="c2 c5">h1</span><span class="c2"> as well as </span><span
class="c2 c5">hr </span><span class="c2">are </span><span
class="c2 c8">perch </span><span class="c2">functions. but they are one
to one similar to the HTML tags. they can be concatenated with the
</span><span class="c2 c5">\<\></span><span class="c2"> operator which
is the general Haskell operator for concatenation, and yes, is in a
class that can be defined for each kind of data. Also for functions like
the ones of </span><span class="c2 c8">perch</span><span class="c2">.
You see that any well defined EDSL uses the same operators, the same
syntax and the same abstractions. You are not learning something
specific, but the general haskell syntax, that can be used to
orchestrate the application integration of a company or to program a
microprocessor.</span>

<span class="c2"></span>

<span class="c2 c5">runBody </span><span class="c2">executes a sequence
of haskell statements that generate DOM elements and attach them to the
body of the HTML document. And here is the magic of the Haskel EDSLs.
 One would think that a Browser application in any language would be a
mix of HTML markup and event handlers with code that call more event
handlers and so on. A well defined Embedded DSL in haskell hides the
complexity and hetereogeneity of the domain within a code which is
intuitive, for example with code with an imperative look.  let´s say
that Haskell uses a deep abstraction of imperative code in which the DSL
programmer specifies what to do between an statement and the next. That
is specified in the instance of the Monad class, which is part of
hplayground in this case. This monad is the Widget monad. what does is
to create event handlers for events in the background.</span>

<span class="c2"></span>

<span class="c2"></span>

<span class="c2">the first statement of the do block add plain HTML to
the DOM below the body of the HTML document. </span><span
class="c2 c5">wraw </span><span class="c2">is a call to insert HTML DOM
elements. </span>

<span class="c2"></span>

<span class="c2">The next block are the three buttons corresponding to
the three options. the </span><span class="c2 c5">\<|\> </span><span
class="c2">operator mix two alternative computations and return the one
that return something valid. When a </span><span class="c2 c5">wbutton,
</span><span class="c2">is pressed will return his first parameter.
 </span>

<span class="c2"></span>

<span class="c2">Until one of the three buttons is pressed, the case
statement is not executed, since there is no valid response, and the
code is waiting in the three event handlers that the hplayground monad
has set waiting to be activated. No blocking is produced.  The event
handler that is triggered in the three options is the same: the case
statement.</span>

<span class="c2"></span>

<span class="c2">Yo see that this is similar to a console application.
It is, but more powerful, since it is not blocking and dynamic, since,
unlike in the case of console applications, the previous widgets in the
sequence are active waiting for your input. Later you will see that it
is a blend of console, reactive, window oriented and spreadsheet
computation at the same time! thanks to the magic of Haskell and the
infinite flexibility of their abstractions.</span>

<span class="c2"></span>

<span class="c2">let´s go for the first option:</span>

<span class="c2"></span>

<span class="c1">edit=  do</span>

<span class="c1">  entries \<- getEntries</span>

<span class="c1">  let num = length entries :: Int</span>

<span class="c1">  wraw \$ div ! id "regnumber" \$ b num  \<\> lb "
registers"</span>

<span class="c1">  </span>

<span class="c1">  r \<-  wbutton True "new Entry" \<|\> wbutton False
"Remove Last entry"</span>

<span class="c1">  case r of</span>

<span class="c1">    True -\> newEntry </span>

<span class="c1">    False -\>  do</span>

<span class="c1">        entries \<- getEntries</span>

<span class="c1">        if null entries then return () else do</span>

<span class="c1">            let entries'= tail entries </span>

<span class="c1">            liftIO \$ setEntries  entries'</span>

<span class="c1">            let num'= num -1</span>

<span class="c1">            at "regnumber" Insert \$ wraw \$ b (num')
\<\> lb " registers"</span>

<span class="c1">        </span>

<span class="c2"></span>

<span class="c2">First, the registers are read from Local Storage using
the haskell procedure </span><span class="c2 c5">getItem </span><span
class="c2">defined in Haste. Local storage is persistent so you will
have them everitime that you run the application.</span>

<span class="c2 c5"></span>

<span class="c1">-- read the entries from Local Storage</span>

<span class="c1">getEntries :: Widget [Entry]</span>

<span class="c1">getEntries= liftIO \$  do</span>

<span class="c1">    mr \<- getItem "budget"</span>

<span class="c1">    case mr of</span>

<span class="c1">        Left \_ -\> return []</span>

<span class="c1">        Right list -\> return list</span>

<span class="c2 c5"> </span>

<span class="c2"></span>

<span class="c2 c5">getEntries </span><span class="c2">is a Widget, like
</span><span class="c2 c5">wbutton</span><span class="c2">, that, when
called return a list of Entries.</span>

<span class="c2"></span>

<span class="c2">The next in </span><span class="c2 c5">edit</span><span
class="c2"> is a </span><span class="c2 c5">wraw</span><span
class="c2"> call which insert a </span><span class="c2 c8">div
</span><span class="c2">tag with an id which includes the number of
registers retrieved. The DOM tree generated in this sentence is:</span>

<span class="c2"></span>

<span class="c1">\<div id="regnumber"\>\<b\>7\</b\>\<span
class="label"\> registers\</span\>\</div\></span>

<span class="c2 c5"></span>

<span class="c2">That is because lb was defined in the application
as:</span>

<span class="c2"></span>

<span class="c1">lb text= span !  class\_ "label" \$ text</span>

<span class="c2"></span>

<span class="c2">the operator ! add attributes to a perch DOM element.
afther the \$ comes the content of the element. in this case the text
“</span><span class="c2 c8">registers</span><span class="c2">”. That is
how perch assemble builder functions to create a DOM subtree. You can
contemplate and use it as if it were HTML, but there is no need for the
close statement. </span>

<span class="c2"></span>

<span class="c2">We use the HTML class to assign CSS styles later. At
main I could set the label style:</span>

<span class="c2"></span>

<span class="c2">addHeader \$ nelem "style"   \`child\` ".label1 {float:
left;width: 20%;}"</span>

<span class="c2"></span>

<span class="c2">That is </span><span class="c2 c8">perch </span><span
class="c2">code. </span><span class="c2 c5">nelem </span><span
class="c2">is a low level primitive that creates any tag, the
</span><span class="c2 c8">\<style\></span><span class="c2"> in this
case. </span><span class="c2 c5">child</span><span class="c2"> is
another low level primitive that append a child node ( in this case, a
text element with the style definition) to the </span><span
class="c2 c8">style </span><span class="c2">element. The reason for this
is because the </span><span class="c2 c8">style </span><span
class="c2">element is not defined, since it collides with the
</span><span class="c2 c5">style </span><span class="c2">attribute, much
more used.</span>

<span class="c2"></span>

<span class="c2">I don´t like styles. I think that CSS is a trap to
convert Web development into a torture. I spent a lot of time trying to
align everything. My failure was to omit a semicolon somewhere.
 Fortunately there are haskell libraries EDSLs) that enforce the
creation of correct CSS definitions by means of the type system. They
can be compiled with haste and used for this purpose here. But not now.
In this example app, I will reduce formatting to the bare
minimum.</span>

<span class="c2"></span>

<span class="c2"> These CSS styles can be in a separate file and
included with </span><span class="c2 c5">addHeader </span><span
class="c2">or it can be defined online. </span><span class="c2 c5">\$
</span><span class="c2">is also a general haskell operator. It means:
t</span><span class="c2 c8">ake what is on the left of me as a function
and execute it with the result of the entire right side as the
parameter.</span>

<span class="c2"></span>

<span class="c2 c5">edit </span><span class="c2">has two options one for
creating a new </span><span class="c2 c5">Entry </span><span
class="c2">and other to delete the last one. This second option uses the
tail function to drop the last addition and then the </span><span
class="c2 c8">hplayground </span><span class="c2">primitive </span><span
class="c2 c5">at</span><span class="c2"> insert, at the “regnumber” div,
just created, the new number of registers. The parameter of </span><span
class="c2 c5">at</span><span class="c2"> is a Widget. In this case, the
static rendering of wraw.</span>

<span class="c2"></span>

<span class="c2 c5">newEntry </span><span class="c2">is a long
procedure. It contains the form and the logic for a new </span><span
class="c2 c5">Entry</span><span class="c2">. It has some new elements.
let´s go for it:</span>

<span class="c2"></span>

<span class="c1">newEntry= do</span>

<span class="c1">  let focus= atr "autofocus" "true"</span>

<span class="c1">  desc \<- br ++\> lb "Enter description: " </span>

<span class="c1">             ++\> inputString Nothing ! size "40"
\`fire\` OnChange </span>

<span class="c1">             \<++ br</span>

<span class="c1">  amount \<- lb "Enter amount: " ++\> inputDouble
Nothing ! focus  \`fire\` OnKeyUp \<++ br</span>

<span class="c1">  </span>

<span class="c1"></span>

<span class="c2">in the first text box, </span><span
class="c2 c5">inputString </span><span class="c2">is a passive text box
that return the content. But it has attached a event handler that fires
with the </span><span class="c2 c8">onchange </span><span
class="c2">event. The </span><span class="c2 c8">hplayground
</span><span class="c2">monad  creates in the background a javascript
event handler. When the user enter content in the input box and press
the Enter key the event handler call the rest of </span><span
class="c2 c5">newEntry</span><span class="c2">. But until this happens,
nothing more is shown in the page. it is like a  input statement in a
console application. This is the default way in which </span><span
class="c2 c8">hplayground </span><span class="c2">operates. But this
style can be overridden for a more static, template based approach that
separates layout and logic. I will detail it later.</span>

<span class="c2"></span>

<span class="c2">The operators </span><span
class="c2 c5">++\></span><span class="c2"> and </span><span
class="c2 c5">\<++</span><span class="c2"> this time are exclusive of
hplayground. the first prepend HTML </span><span class="c2 c8">perch
</span><span class="c2">formatting to the </span><span
class="c2 c5">inputString</span><span class="c2"> widget. the second one
append it. </span>

<span class="c2"></span>

<span class="c2">The second  input statement is similar. In this case it
gets a valid double number. If the user enters something that is a
number, the computation will not continue.</span>

<span class="c2"></span>

<span class="c2">This is HTML DOM generated by the “</span><span
class="c2 c8">Enter description</span><span class="c2">” statement when
it is empty waiting for input is:</span>

<span class="c2"></span>

<span class="c1">\<span id="p22"\></span>

<span class="c1">   \<br\></span>

<span class="c1">    \<span class="label"\>Enter description:
\</span\></span>

<span class="c1">   \<input type="text" id="p37" value="" size="40"
change="true"\></span>

<span class="c1">   \<br\></span>

<span class="c1">   \<span id="p36"\>\</span\></span>

<span class="c1">\</span\></span>

<span class="c2"></span>

<span class="c2">The empty span </span><span class="c2 c5">p36
</span><span class="c2">is where the rendering generated by the
trcallback will be located when triggered</span>

<span class="c2"></span>

<span class="c2">The next in the newEntry procedure is to ask for the
date of the entry.</span>

<span class="c2"></span>

<span class="c1">  day   \<- getDay</span>

<span class="c1">  month \<- getMonth</span>

<span class="c1">  year  \<- getYear</span>

<span class="c1">  </span>

<span class="c1">  (day, month,year) \<- getDate (day,month,year)</span>

<span class="c1">  </span>

<span class="c1"></span>

<span class="c2 c5">getDate </span><span class="c2">receives the date of
today as the parameter. And this is obtained calling JavaScript. These
four functions will be explained later.</span>

<span class="c2"></span>

<span class="c2">Next in </span><span class="c2 c5">addEntry
</span><span class="c2">is a set of radio buttons. They have attached
“</span><span class="c2 c8">onclick</span><span class="c2">”
events.</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1">  typer \<- getRadio(</span>

<span class="c1">               [\\n -\> lb "Travel "++\> setRadio
 Travel  n  \`fire\` OnClick \<++ br</span>

<span class="c1">               ,\\n -\> lb "Food "  ++\> setRadio  Food
 n  \`fire\` OnClick \<++ br</span>

<span class="c1">               ,\\n -\> lb "Entertainment" ++\>
setRadio  Entertain n \`fire\` OnClick \<++ br</span>

<span class="c1">               ,\\n -\> lb "Other " ++\> setRadio
 Other n     \`fire\` OnClick \<++ br]</span>

<span class="c1"></span>

<span class="c1">               ,\\n -\> hr ++\> lb "Income " ++\>
setRadio Income n  \`fire\` OnClick \<++ br])</span>

<span class="c1"></span>

<span class="c2">The radio buttons are in a list. They are what in
functional languages are called lambda expressions. the parameter of the
lambda expression is the common identifier provided by </span><span
class="c2 c5">getRadio.</span><span class="c2"> This arguably too
complicated and will be  simplified soon.</span>

<span class="c1"></span>

<span class="c1">  </span>

<span class="c1">  let newEntry= Entry day month year desc amount
typer</span>

<span class="c1">  </span>

<span class="c1">  h1 "Click here to confirm" \`pass\` OnClick </span>

<span class="c1">  </span>

<span class="c2">That is something new.  first the register is created
using the </span><span class="c2 c5">Entry </span><span
class="c2">constructor taking as input the results of the previous
widgets. And the there is a text in H1 formating with a </span><span
class="c2 c8">onclick </span><span class="c2">event attached.
</span><span class="c2 c5">newEntry </span><span class="c2">will not
continue beyond this point if the text is not clicked.  </span><span
class="c2 c5">pass</span><span class="c2"> assing a event handler to
HTML code, while </span><span class="c2 c5">fire </span><span
class="c2">assign it to a widget. </span><span class="c2 c8">pass
</span><span class="c2">return the event content, while </span><span
class="c2 c5">fire </span><span class="c2">return the widget content.
 </span><span class="c2 c8">pass </span><span class="c2">can be used to
create active widgets. For example  </span><span class="c2 c5">wbutton
</span><span class="c2">is defined in the module Haste.HPlay.View
as:</span>

<span class="c2"></span>

<span class="c1">-- | active button. When clicked, return the button
value</span>

<span class="c1">wbutton :: a -\> String -\> Widget a</span>

<span class="c1">wbutton x label= do</span>

<span class="c1">        input  ! atr "type" "submit" ! atr "value"
label \`pass\` OnClick</span>

<span class="c1">        return x</span>

<span class="c2"></span>

<span class="c2">With this hint and a little knowledge of HTML and CSS
you will probably will be capable to create option tab widgets, that
substitute the </span><span class="c2 c5">wbutton </span><span
class="c2">widgets of the three main options above.</span>

<span class="c2"></span>

<span class="c2">The only remaining thing in newEntry is to add the new
entry to the storage and to update the number of registers in the
“</span><span class="c2 c8">regnumber</span><span class="c2">” div
element.</span>

<span class="c2"></span>

<span class="c1">  entries \<- getEntries</span>

<span class="c1">  liftIO \$ setEntries \$ newEntry  : entries</span>

<span class="c1">  let num= length entries + 1  </span>

<span class="c1">  </span>

<span class="c1">  wraw \$ lb "Registered! "</span>

<span class="c1">  at "regnumber" Insert \$ wraw \$ b num \<\> lb "
registers"</span>

<span class="c2"></span>

<span class="c2"></span>

<span class="c2">This is how the Edit option will look like:</span>

<span class="c2"></span>

<span
style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 424.00px;">![](images/image01.png)</span>

<span class="c2">Yo can see that the code is very close to the problem
and there are no plumbing. That is because the abstraction that the
haskell monads used by hplayground. </span>

<span class="c2"></span>

<span class="c2">The type system allows for experimentation and
factorization without care for the details, since it will warn about
missing variables, mismatches in the number and type of parameters,
improperly located calls etc.</span>

<span class="c2"></span>

<span class="c2">Only there is a downside of all these advantages: While
the hplayground EDSL you and me speak in terms of HTML DOM, combo boxes,
events textareas, procedures etc,  the type system speaks in
haskell.</span>

<span class="c2"></span>

<span class="c2">For example if we omit Insert in the last line on the
above snippet we will have two long errors in the same line. One of them
say nothing interesting. The other start with:</span>

<span class="c2"></span>

<span class="c2 c5">mybudget.hs:71:31:\
    Couldn't match type \`View Perch IO ()' with \`UpdateMethod'\
    Expected type: UpdateMethod\
      Actual type: Widget ()</span>

<span class="c2"></span>

<span class="c2 c5">UpdateMethod </span><span class="c2">is the type of
Insert. If you search for it on google, go to the hplayground
documentation </span><span
class="c11 c3">[here](https://www.google.com/url?q=https%3A%2F%2Fhackage.haskell.org%2Fpackage%2Fhplayground-0.1.0.4%2Fdocs%2FHaste-HPlay-View.html%23v%3Aat&sa=D&sntz=1&usg=AFQjCNEbCHK9710V3uQR3aXO23whccD9PQ)</span><span
class="c2"> you wil see it. What the error means is that instead of a
UpdateMethod, there is a widget, that must be the secon parameter, not
the first. </span>

<span class="c2"></span>

<span class="c2">if you work with a EDSL  the kinds of errors are
constrained to a few variations. Once you know what they mean, by
looking at the examples, you can figure out what to do. The good thing
is that you will not experience the consequences of these errors at
runtime. But expect some time spent interacting with the
compiler.</span>

<span class="c2"></span>

<span class="c2">The query functionality is in the </span><span
class="c2 c5">viewEntries </span><span class="c2">procedure which has
some other interesting things to mention:</span>

<span class="c2"></span>

<span class="c2"></span>

<span class="c1">viewEntries :: Widget ()</span>

<span class="c1">viewEntries= do</span>

<span class="c1">   wraw \$ br \<\> lb "from:" </span>

<span class="c1">   today@(d,m,y) \<- (,,) \<\$\> getDay \<\*\> getMonth
\<\*\> getYear</span>

<span class="c1">   (dayf,monthf,yearf) \<- getDate (d,if m \> 1 then
m-1 else m, y)</span>

<span class="c1">   wraw \$ br \<\> lb "to:"</span>

<span class="c1">   (dayt,montht,yeart) \<- getDate today</span>

<span class="c1">   </span>

<span class="c1">   let filter reg=</span>

<span class="c1">        let yearr= year reg; monthr = month reg; dayr=
day reg</span>

<span class="c1">        </span>

<span class="c1">        in  yearr \> yearf && yearr \< yeart ||</span>

<span class="c1">            yearr == yearf && monthr \> monthf
||</span>

<span class="c1">            yearr == yeart && monthr \< montht
||</span>

<span class="c1">            monthr == monthf && dayr \>= dayf ||</span>

<span class="c1">            monthr == monthr && dayr \<= dayr</span>

<span class="c1"> </span>

<span class="c1">   detailByFilter filter </span>

<span class="c2"></span>

<span class="c2">It is a sequential procedure that ask for an initial
and final date to filter and present the entries with </span><span
class="c2 c5">detailByFilter</span><span class="c2">. But here is the
first example of another way of computation in Haskell: the applicative
style:</span>

<span class="c2"></span>

<span class="c1">today@(d,m,y) \<- (,,) \<\$\> getDay \<\*\> getMonth
\<\*\> getYear</span>

<span class="c2"></span>

<span class="c2 c5">\<\$\></span><span class="c2"> and</span><span
class="c2 c5"> \<\*\></span><span class="c2"> are standard haskell
applicative operators. This right expression means: execute </span><span
class="c2 c5">getDay</span><span class="c2">, </span><span
class="c2 c5">getMonth </span><span class="c2">and </span><span
class="c2 c5">getYear </span><span class="c2">and pack their results in
a 3-tuple. The left expression is a pattern match. It says that the
3-tuple will be called today, assign the day to </span><span
class="c2 c5">d</span><span class="c2">, the month to </span><span
class="c2 c5">m </span><span class="c2">and the year to </span><span
class="c2 c5">y .</span><span class="c2"> Applicative expressions in
hplayground generate static layour and his rendering is executed fully.
A more complex example is </span><span class="c2 c5">getDate:</span>

<span class="c2 c5"></span>

<span class="c1">getDate (day, month, year)= </span>

<span class="c1">      (,,)   \<\$\> lb "dd/mm/yyyy" </span>

<span class="c1">             ++\> inputInt (Just day)    ! length\_ "2"
! size "2"</span>

<span class="c1">                   \`validate\` (\\d -\> return (if d\>
1 && d \<31 </span>

<span class="c1">                                             
        then Nothing </span>

<span class="c1">           else Just \$ b "wrong"))</span>

<span class="c1">             \<\*\> inputInt (Just month)  ! length\_
"2" ! size "2"</span>

<span class="c1">                   \`validate\` (\\m -\> return (if
m\>1 && m \< 12 </span>

<span class="c1">                                                 then
Nothing </span>

<span class="c1">else Just \$ b "wrong"))</span>

<span class="c1">             \<\*\> inputInt (Just year)   ! length\_
"4" ! size "4"</span>

<span class="c1">             \<\*\* inputSubmit "Ok" \`fire\`
OnClick</span>

<span class="c1">             \<++ br</span>

<span class="c2 c5"></span>

<span class="c2"></span>

<span class="c2">This procedure generates the same kind of data: It
return a 3-tuple. It has the \<\$\> and two \<\*\> operators, but the
operands are now imput boxes for Int values. these inputInt use the
</span><span class="c2 c5">validate </span><span class="c2">hplayground
procedure. It takes the value entered by the user and execute the
expression. if the validators has </span><span
class="c2 c5">Nothing</span><span class="c2"> objectionable, the
applicative expression return the 3-tuple.</span>

<span class="c2"></span>

<span class="c2">As you can see it is rather primitive. It uses plain
boxes instead of combo boxes. it may have integrated pretty javascript
libraries that present a beatiful calendar and so on using the same
techniques used in the google graph and so on.</span>

<span class="c2"></span>

<span class="c2">The applicative style computation can be used to
generate static layouts. getDate also have some formatting, added with
the operators ++\> and \<++ already mentioned.  A new applicative
operator </span><span class="c2 c5">\<\*\*</span><span class="c2"> is
introduced here. it is specific of hplayground, but it is very similar
to the standard applicative operator </span><span class="c2 c5">\<\*
</span><span class="c2">Both discard the value of the operand that is
after it, but add his rendering, but the first is executed wether the
left is validated or not, while the second do not execute in this case.
Since a form is necessary to be rendered fully no matter if the value
entered is valiated or not, the  </span><span class="c2 c5">\<\*\*
</span><span class="c2">operator is necessary. The same could be said
for</span><span class="c2 c5"> \<\*\*</span><span
class="c2"> and</span><span class="c2 c5"> \<\*</span><span
class="c2"> that operate in the other side.</span>

<span class="c2"></span>

<span class="c2">Some words about operator priorities: The absence of
parenthesis is due to a careful choose of the operator priorities. The
applicative operatos have less priorty that the HTML formatting
operators, so the ++ operators are more stiky. However to start with the
use of operators, if you have any doubt, enclose the operands in
parenthesis if you are not sure. The haskell erros due to wrong grouping
of operands are usually unintelligible. Use parenthesis then.</span>

<span class="c2"></span>

<span class="c2 c5">detailByFilter </span><span class="c2">gets the
filter function defined in </span><span class="c2 c5">viewEntries
</span><span class="c2">It uses some standard functional
primitives...</span>

<span class="c2"></span>

<span class="c1">detailByFilter fil  = do</span>

<span class="c1">    regs' \<- getEntries</span>

<span class="c1">    let regs = filter regs'</span>

<span class="c1">        filterByType type\_ rs= filter (\\r -\> etype r
== type\_) rs</span>

<span class="c1"></span>

<span class="c1">        total :: EntryType -\> Double</span>

<span class="c1">        total typer=sum \$ L.map amount \$ filterByType
typer regs</span>

<span class="c1">        </span>

<span class="c1">        travel= total Travel</span>

<span class="c1">        food=   total Food</span>

<span class="c1">        enter=  total Entertain</span>

<span class="c1">        other=  total Other</span>

<span class="c1">        income= total Income</span>

<span class="c1"></span>

<span class="c2">Like filter, sum and map. they are used to filter the
registers that meet the criteria and to obtain the total expent by each
concept.</span>

<span class="c2"></span>

<span class="c2">What comes next is a alternative between link widgets.
</span><span class="c1"> </span>

<span class="c1">      </span>

<span class="c1">    typer \<-    wlink Income \<\< lb " Income: " \<++
b income</span>

<span class="c1">            \<|\> wlink Travel \<\< lb " Travel: " \<++
b  travel</span>

<span class="c1">            \<|\> wlink Food   \<\< lb " Food: " \<++ b
 food</span>

<span class="c1">            \<|\> wlink Entertain  \<\< lb "
Entertainment" \<++ b  enter</span>

<span class="c1">            \<|\> wlink Other  \<\< lb "Other: " \<++ b
 other</span>

<span class="c1">            \<|\> return AllEntries</span>

<span class="c2"></span>

<span class="c2">I mentioned the alternative </span><span
class="c2 c5">\<|\></span><span class="c2"> operator. it return the
result of the first widget that validates. In this case, </span><span
class="c2 c5">wlink </span><span class="c2">renders as a link. It has
two parameters. Like </span><span class="c2 c5">wbutton, </span><span
class="c2">when cllicked, it return the first parameter. The second
parameter is the HTML code of the link. the operator \<\< add the
content to a Widget or a HTML container element. It is similar to \$ but
it has more priority. That is necessary in Applicative or Alternative
contexts like this. </span>

<span class="c2"></span>

<span class="c2">But note the last alternative above: it is simply a
return statement. It means that if none of the links is pressed,
</span><span class="c2 c5">AllEntries </span><span class="c2">will be
returned.  So this alternative combination ever return something. That
means that then next statement in the do sequence will be ever
executed.</span>

<span class="c2"></span>

<span class="c2">But this is not the end of the statement (below). There
is more. First a </span><span class="c2 c5">do </span><span
class="c2">with  three HTML statements. What is that?  It is content in
the perch monad. This monad just concatenate HTML statements.</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1">            \<++ do hr </span>

<span class="c1">                   lb "Balance: " </span>

<span class="c1">                   b (income - travel - food - enter -
other)</span>

<span class="c1"></span>

<span class="c2">So the expression above is equivalent to</span><span
class="c2 c5"> : hr \<\> lb “Balance “ \<\>  b(income…. </span><span
class="c2">The advantage of the do notation is that it can express
better the tree structure of HTML and he DOM when the rendering gets
complicated. In this aplication the do notation is used for three
monads: Widget, perch and IO.</span>

<span class="c1"></span>

<span class="c1">            \<\*\* drawIt (("Type", "Spent")</span>

<span class="c1">                       ,("Travel",  travel)</span>

<span class="c1">                       ,("Food",   food)</span>

<span class="c1">                       ,("Entertainment", enter)</span>

<span class="c1">                       ,("Other",   other)</span>

<span class="c1">                       ,("Income",   income))</span>

<span class="c1"></span>

<span class="c1">                       </span>

<span class="c1">    let filtered = if typer == AllEntries then regs
else filterByType typer regs</span>

<span class="c1">    detail  filtered</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c2">Finally the alternative expression attach the chart
graph using the </span><span class="c2 c5">\<\*\*</span><span
class="c2"> operator mentioned above. It add nothing to the logic of the
procedure, but it append the rendering.  It receives the calculated
values to create the chart graph. More on the chart graphic
later.</span>

<span class="c2"></span>

<span class="c2">Finally if one of the links is clicked, the register of
this type are filtered and presented with </span><span
class="c2 c5">detail.</span><span class="c2"> If none of them is
clicked, all the entries within the two dates are presented.</span>

<span class="c2"></span>

<span class="c2 c5">detail </span><span class="c2">creates a static
presentation of the entries using the perch monad.</span>

<span class="c2"></span>

<span class="c1">detail  registers= wraw \$ do</span>

<span class="c1">    h3 "Al registers selected:"</span>

<span class="c1">    </span>

<span class="c1">    div \$ do</span>

<span class="c1">      lb \$ b "Date"</span>

<span class="c1">      lb \$ b “Type”</span>

<span class="c1">      lb \$ b "Description"</span>

<span class="c1">      lb \$ b "Amount"</span>

<span class="c1">      br</span>

<span class="c1"></span>

<span class="c1">    let formatEntry (Entry day month year desc amount
typer)= </span>

<span class="c1">         div \$ do</span>

<span class="c1">          span ! st10 \$ show day++"-"++show
month++"-"++show year</span>

<span class="c1">          span ! st30 \$ typer</span>

<span class="c1">          span ! st50 \$ desc</span>

<span class="c1">          span ! st70 \$ amount</span>

<span class="c1"></span>

<span class="c1">    mconcat [formatEntry entry | entry \<-
registers]</span>

<span class="c2"></span>

<span class="c2">It defines </span><span class="c2 c5">formatEntry
</span><span class="c2">to present a register. Then call it for each
register using Haskell list comprehension and concatenate all using
</span><span class="c2 c5">mconcat. </span>

<span class="c2 c5"></span>

<span class="c2 c5"></span>

<span class="c2">This is how the View entries option looks like:</span>

<span class="c2"></span>

<span
style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 498.67px;">![](images/image00.png)</span>

<span class="c2 c5"></span>

<span class="c2 c5"></span>

<span class="c2">The </span><span class="c2 c5">preview </span><span
class="c2">option is more spreadsheet-like. </span>

<span class="c2"></span>

<span class="c1">preview= do</span>

<span class="c1">    changed \<-  h3 "Preview" </span>

<span class="c1">            ++\> h4 "Recalculate the budget according
with priorities and present a chart graph"</span>

<span class="c1">            ++\> lb "Income"   ++\> cell Income  \<++
br </span>

<span class="c1">            \<|\> lb "Travel" ++\> cell Travel \<++
br</span>

<span class="c1">            \<|\> lb "Food"   ++\> cell Food \<++ br
</span>

<span class="c1">            \<|\> lb "Entertainment" ++\>  cell
Entertain \<++ br</span>

<span class="c1">            \<|\> lb "Other"   ++\> cell Other \<++ br
</span>

<span class="c1">             </span>

<span class="c2 c6">The first lines present an alternative list of
 cells. it is defined below as:</span>

<span class="c2 c6"></span>

<span class="c1">    cell :: EntryType -\> Widget EntryType</span>

<span class="c1">    cell t= do</span>

<span class="c1">            mk (boxCell (show t) :: Cell Double)
Nothing  \`fire\` OnKeyUp </span>

<span class="c1">            return t</span>

<span class="c2 c6"></span>

<span class="c2">That renders a text box. When  a key is hit in the box,
the cell return the expense type that has been modifed.</span>

<span class="c2 c5">mk </span><span class="c2">and </span><span
class="c2 c5">boxCell </span><span class="c2">are defined in
</span><span class="c2 c5">Haste.HPlay.Cell </span><span class="c2">in
essence a </span><span class="c2 c5">boxCell </span><span class="c2">is
a text box which is polimorphic, it can read any kind of data as long as
it has a </span><span class="c2 c5">Read </span><span
class="c2">instance. That´s why the signature (</span><span
class="c2 c5">Cell Double</span><span class="c2">) is necessary to
specify what we need.  A cell can also be read with </span><span
class="c2 c5">get </span><span class="c2">and assigned with the operator
</span><span class="c2 c5">.=</span><span class="c2"> . The </span><span
class="c2 c5">mk</span><span class="c2"> primitive renders the cell in
the page. </span>

<span class="c2 c6"></span>

<span class="c2">These methods are used below to recalculate the budget
according with priorities: The income is distributed among the expenses,
The increase or decrease of other expenses change the Entertainment
budget to match the Income. If entertainment is modified, the Other
expenses are modified accordingly.  It is simplistic and unreal, but
works as an example of the cell usage.</span>

<span class="c2 c6">  </span>

<span class="c2 c6"> </span><span class="c1">   </span>

<span class="c1">    t \<- get \$ boxCell "Travel";    f \<- get \$
boxCell "Food"</span>

<span class="c1">    e \<- get \$ boxCell "Entertain"; o \<- get \$
boxCell "Other"</span>

<span class="c1">    i \<- get \$ boxCell "Income" :: Widget
Double</span>

<span class="c1">   </span>

<span class="c1">    (i,f,o,t,e) \<-case changed of</span>

<span class="c1">        Travel    -\> let e= i- f- o- t in do boxCell
"Entertain" .= e ; return  (i,f,o,t,e) </span>

<span class="c1">        Food      -\> let e= i- f- o- t in do boxCell
"Entertain" .= e ; return  (i,f,o,t,e) </span>

<span class="c1">        Entertain -\> let o= i- f- e- t in do boxCell
"Other" .= o ; return  (i,f,o,t,e) </span>

<span class="c1">        Other     -\> let e= i- f- o- t in do boxCell
"Entertain" .= e ; return  (i,f,o,t,e) </span>

<span class="c1">        Income    -\> let e= i- f- o- t in do boxCell
"Entertain" .= e ; return  (i,f,o,t,e) </span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c2">Actually, hplayground has a experimental solver of cell
dependencies that works like a spreadsheet that can solve this problem
in a more elegant way, but it is being under test.</span>

<span class="c2"></span>

<span class="c2">After updating the cells, the result is presented in a
chart graph:</span>

<span class="c1"></span>

<span class="c1">    if( t \>= 0 && f \>= 0 && e \>= 0 && o \>= 0 &&
i \>= 0) </span>

<span class="c1">      then</span>

<span class="c1">       drawIt(("Type", "Spent")</span>

<span class="c1">             ,("Travel",  t)</span>

<span class="c1">             ,("Food",   f)</span>

<span class="c1">             ,("Entertainment", e)</span>

<span class="c1">             ,("Other",   o)</span>

<span class="c1">             ,("Income",   i))</span>

<span class="c1">      else</span>

<span class="c1">        wraw \$ b "No graphics since some quantity is
negative"</span>

<span class="c1"></span>

<span class="c2">That is how the </span><span class="c2 c5">preview
</span><span class="c2">option looks like</span>

<span
style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 444.00px; height: 473.00px;">![](images/image02.png)</span><span
class="c1">    </span>

<span class="c2">Since the code is executed when a key is pressed, the
 distribution will be recalculated and the chart will be redrawn with
each key pressed. This illustrates well the reactive capabilities of
hplayground.</span>

<span class="c2"></span>

<span class="c2">And then the low level code that interact with
JavaScript, to illustrate how to use javascript libraries from Haskell.
</span>

<span class="c2"></span>

<span class="c2">The javascript snippet  that load and integrate the
chart is explained at </span>

<span class="c2"></span>

<span class="c11 c3"><https://developers.google.com/chart/></span>

<span class="c2"></span>

<span class="c2">The haskell code below include essentially the same
HTML (as perch code) and JavaScript (as embedded strings inside the
perch code.  </span><span class="c2 c5">googleGraph </span><span
class="c2">includes the static code necessary for including the library
It is called at main. </span><span class="c2 c5">drawIt </span><span
class="c2">is the chart drawing procedure. it create the canvas and draw
the chart with the passed parameters. this last is called in two
different places in the application.  </span>

<span class="c2"></span>

<span class="c2"></span>

<span class="c1">googleGraph :: perch</span>

<span class="c1">googleGraph= do</span>

<span class="c1">    script ! atr "type" "text/javascript" ! src
"https://www.google.com/jsapi" \$ noHtml</span>

<span class="c1">    script ! atr "type" "text/javascript" \$ do</span>

<span class="c1">     "var options;\\</span>

<span class="c1">     \\function init(){\\</span>

<span class="c1">      \\google.load('visualization', '1',
{packages:['corechart'],'callback' : drawChart});\\</span>

<span class="c1">      \\function drawChart() {\\</span>

<span class="c1">        \\options = {\\</span>

<span class="c1">          \\title: 'Preview expenses'\\</span>

<span class="c1">        \\};\\</span>

<span class="c1">      \\}}\\</span>

<span class="c1">     \\function waitGoogle(){\\</span>

<span class="c1">        \\if (typeof google !== 'undefined')
{init();}\\</span>

<span class="c1">       
\\else{window.setTimeout(function(){waitGoogle();}, 10);}}\\</span>

<span class="c1">     \\waitGoogle();"</span>

<span class="c1"></span>

<span class="c2 c5">googleGraph </span><span class="c2">includes all the
static setup, that is an almost exact copy of the first example from
google. The HTML is generated dynamically, but it could have been
included in the HTML page. Being in the code makes the maintenance more
flexible for quick applications. If I want to change the options
dynamically, I only have to cut and paste from </span><span
class="c2 c5">googleGraph </span><span class="c2">to </span><span
class="c2 c5">drawIt</span><span class="c2">.</span>

<span class="c2"></span>

<span class="c2 c5">drawIt </span><span class="c2">includes the dynamic
part. Since it will be called in two different parts in the application
in different page locations, the canvas must be created dynamically by
the event handler, I mean, the statement in the sequence that display it
since the hplayground monad construct the event handlers  in the
background:</span>

<span class="c1">     </span>

<span class="c1">drawIt dat= do</span>

<span class="c1">    wraw \$ div ! id "piechart" ! style "width: 900px;
height: 500px;" \$ do</span>

<span class="c1">         lb "Please connect to Internet to download the
"</span>

<span class="c1">         a ! href
"https://google-developers.appspot.com/chart/interactive/docs/gallery/piechart"</span>

<span class="c1">           \$ "Pie Chart graphics" </span>

<span class="c1">         lb "from Google"</span>

<span class="c1">    </span>

<span class="c1">    wraw \$ liftIO \$ drawIt' dat</span>

<span class="c1"></span>

<span class="c2">The canvas is a div element. If the canvas is not
created due to a connection failure, the text above is displayed.
</span><span class="c2 c5">drawIt’ </span><span class="c2">creates the
canvas and display the chart:</span>

<span class="c2"></span>

<span class="c1">    where</span>

<span class="c1">    drawIt'= ffi \$ toJSString </span>

<span class="c1">                "(function (data){\\</span>

<span class="c1">                 \\var chart = new
google.visualization.PieChart(document.getElementById('piechart'));\\</span>

<span class="c1">                 \\return
chart.draw(google.visualization.arrayToDataTable(data),
options);})"</span>

<span class="c1"></span>

<span class="c2 c5">ffi </span><span class="c2">is a Haste primitive
that marshall haskell parameters from/to javascript. Haskell tuples,
</span><span class="c3 c11">[according with the
documentation](https://www.google.com/url?q=https%3A%2F%2Fhackage.haskell.org%2Fpackage%2Fhaste-compiler-0.4.2%2Fdocs%2FHaste-Foreign.html&sa=D&sntz=1&usg=AFQjCNGhke9dG-mKdNakeeBGMweygCfDxw)</span><span
class="c2">, are converted to javascript arrays. That is what we need.
</span><span class="c2 c5">toJSString </span><span class="c2">convert
haskell strings to javaScript strings. TODO: include pointers
documentation etc.</span>

<span class="c1"></span>

<span class="c2">Finally the date of today is obtained from javaScript
using </span><span class="c2 c5">ffi </span><span class="c2">too. It
could have been compressed in a single call too:</span>

<span class="c1"></span>

<span class="c1">getDay :: Widget Int</span>

<span class="c1">getDay= liftIO \$ ffi \$ toJSString "(function(){return
new Date().getDate()})"</span>

<span class="c1"></span>

<span class="c1">getMonth :: Widget Int</span>

<span class="c1">getMonth= liftIO \$ ffi \$ toJSString
"(function(){return new Date().getMonth()+1})"</span>

<span class="c1"></span>

<span class="c1">getYear :: Widget Int</span>

<span class="c1">getYear= liftIO \$ ffi \$ toJSString
"(function(){return new Date().getFullYear()})"</span>

<span class="c2"></span>

<span>Template-style programming</span><span>: Separati</span><span>ng  layout from logic:</span> {.c0 .c9}
-------------------------------------------------------------------------------------------------

<span></span>

<span class="c3">For more static and  traditionalist approaches, the
layout and the logic can be separated. The HTML can be coded in the HTML
template or it can be created online as perch sentences. The
</span><span class="c3 c5">preview </span><span class="c3">functionality
has a form with some labels:</span>

<span></span>

<span class="c5 c6">preview= do</span>

<span class="c5 c6">    changed \<-  h3 "Preview" </span>

<span class="c5 c6">           ++\> h4 "Recalculate the budget accoring
with priorities and present a chart graph"</span>

<span class="c5 c6">           ++\> lb "Income"   ++\> cell Income  \<++
br </span>

<span class="c5 c6">           \<|\> lb "Travel" ++\> cell Travel \<++
br</span>

<span class="c5 c6">           \<|\> lb "Food"   ++\> cell Food \<++ br
</span>

<span class="c5 c6">           \<|\> lb "Entertainment" ++\>  cell
Entertain \<++ br</span>

<span class="c5 c6">           \<|\> lb "Other"   ++\> cell Other \<++
br </span>

<span class="c5 c6">   …</span>

<span class="c3">That code mixes HTML layout and texts  with active cell
widgets. This may not be a problem when the layout is light like in this
case, but sometimes it may be convenient to use a WYSIWYG tool to create
the HTML template. Or it may be more clear to inline the HTML in perch
sentences. </span>

<span></span>

<span class="c3">The code below  is equivalent, It separates the layout
(as perch sentences) and the widget code in the Widget monad:</span>

<span> </span>

<span class="c5 c6">preview= do             </span>

<span class="c5 c6">    wraw \$ do  -- layout in the perch monad</span>

<span class="c5 c6">            h3 "Preview" </span>

<span class="c5 c6">            h4 "Recalculate the budget accoring with
priorities and present a chart graph"</span>

<span class="c5 c6">            lb "Income" \<\> (span ! id
"incomeholder" \$ noHtml) \<\> br</span>

<span class="c5 c6">            lb "Travel" \<\> (span ! id
"travelholder" \$ noHtml) \<\> br</span>

<span class="c5 c6">            lb "Food"   \<\> (span ! id "foodholder"
\$ noHtml )  \<\> br</span>

<span class="c5 c6">            lb "Entertainment"  \<\> (span ! id
"enterholder" \$ noHtml)  \<\> br</span>

<span class="c5 c6">            lb "Other"  \<\> (span ! id
"otherholder" \$ noHtml)  \<\> br</span>

<span class="c5 c6">            </span>

<span class="c5 c6">    -- logic, in an alternative expression</span>

<span class="c5 c6">    changed \<-  at "incomeholder" Insert (cell
Income)</span>

<span class="c5 c6">            \<|\> at "travelholder" Insert (cell
Travel)</span>

<span class="c5 c6">            \<|\> at "foodholder"   Insert (cell
Food)</span>

<span class="c5 c6">            \<|\> at "enterholder"  Insert (cell
Entertain)</span>

<span class="c5 c6">            \<|\> at "otherholder"  Insert (cell
Other)</span>

<span></span>

<span></span>

<span class="c3">the span placeholders are updated by the logic when
executed. The perch code can be  omited if the layout is created in the
HTML if the page is static and it has only this option. This is not the
case of this application.</span>

<span></span>

<span>Conclussions:</span> {.c0 .c9}
--------------------------

<span></span>

<span class="c3">I think that the code is pretty understandable at first
sight. This is because the EDSL abstract all the event handlers under
intuitive metaphors for sequencing taken from imperative programming and
console input-output. There are some other abstractions such are the
alternative operators that are easy to understand and other less
intuitive, like the applicative ones. The perch layout is one-to-one
similar to HTML.</span>

<span></span>

<span class="c3">Although Haste, the haskell to Javascript compiler and
the libraries used here are pretty new, The type system of Haskell makes
them solid at least for quick in house development, substituting Excel
spreadsheets and some window-oriented or console applications. Ajax can
be used to interact with any web server. It is not explained here, but
it is pretty simple. Maybe in another article.</span>

<span class="c3"></span>

<span class="c3">There may be an evolution for the creation of more
useful, higher level widgets. As I demonstrated with the drawIt widget,
these new functionalities can  integrate  javascript libraries, so
haskell can be used for any kind of browser application, including
smartphone applications.</span>

